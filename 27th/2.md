# 法一：暴搜

1. 一个n位的2进制数，每一位选or不选即可
2. `i>>j&1` 用来判断第j位是否为1，从最低位（第0位开始）
3. `i< 1<<n` 则是遍历一个n为二进制数，0-$2^n$

# 法二：01背包

1. 要使得花费最小，实则要使sum-x这一段取n本书的总和最大
2. 背包容量为sum-x
3. 每一个物品的体积为a[i]，每一个物品的价值也为a[i]
4. 所以正序遍历物品，逆序循环体积（打板子） （逆序遍历体积是因为在一维背包下，状态的更新取决于前置状态，但是前序状态已经被污染，如果是二维则可以正序遍历体积）


# 01背包

#### 1.二维状态

```cpp
for(int i=1;i<=n;++i)       //遍历物品
    for(int j=1;j<=m;++j){  //遍历体积
        if(j<v[i])
            f[i][j]=f[i-1][j];//拿不了 则第i个状态的价值等价于第i-1个状态
        else
            f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]);
    }
```

#### 2.一维状态

1.直接定义 `f[j]` 为n个物品下容量为j的背包的最优解 这样就可以直接决策到第i件物品
2.一定得逆序遍历体积，避免前置状态被污染(若j从小到大，f[j-v[i]]中，由于j-v[i]小于j，f[j-v[i]]已经在i这层循环被计算了，而我们想要的f[j-v[i]]应该是i-1层循环里面的，所以j从大到小的话保证此时的f[j-v[i]]还未被计算，也就是第i-1层的数据)
3.同时我们枚举的背包容量只有在大于`v[i]`的时候才会更新状态，所以我们可以继续优化循环终止的条件

```cpp
for(int i=1;i<=n;++i)
    for(int j=m;j>=v[i];--j)
        f[j]=max(f[j],f[j-v[i]]+w[i]);
```