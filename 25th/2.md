![1684246661034](image/2/1684246661034.png)


# 前缀和

1.定义一个`sum[]`数组，`sum[i]`代表`a`数组中前`i`个数的和。
```cpp
for(int i = 1; i <= n;i++)
{ 
    sum[i] = sum[i - 1] + a[i];   
}
```

2.查询l到r的和

只需要O(1)的时间复杂度即可
```cpp
sum[r]-sum[l-1]
```

# 差分

1.可以直接理解成前缀和的逆运算

![1684252003109](image/2/1684252003109.png)

2.区间l到r全部加上c
时间复杂度O(1)

**a数组是b数组的前缀和数组**，比如对`b`数组的`b[i]`的修改，会影响到`a`数组中从`a[i]`及往后的每一个数。

```cpp
b[l] += c;     //将序列中[l, r]之间的每个数都加上c
b[r + 1] -= c;

for (int i = 1; i <= n; i++)
{
    a[i] = b[i] + a[i - 1];    //前缀和运算
    printf("%d ", a[i]);
}
```
当然也可以直接
```cpp
for(int i=1;i<N;++i)
    b[i]+=b[i-1];
```
这样得到的就是a数组